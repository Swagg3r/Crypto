Les antivirus (AV) sont les programmes de sécurité les plus utilisés. Ce sont des programmes installés sur les machines des utilisateurs. Les antivirus sont lancés par l'OS avant l'initialisation du système de fichiers et du réseau. Cet outil permet de détecter les malwares et les empêche de s’exécuter sur le système. Il existe différentes manières de détecter un malware : 

Scan par signature : L'AV va calculer la signature d'un fichier ou d'un morceau de code et va le comparer à une base de données. Méthode inefficace contre les malwares polymorphes ou capable de changer leur signature.
Analyse heuristique : Méthode la plus puissante car elle permet de simuler l’exécution du code d'un programme dans une zone contrôlée. Ainsi, l'AV peut observer le comportement du code qui s’exécute et définir si il s'agit d'un malware ou non. Cette méthode peut provoquer des fausses alertes.
Contrôle d'intégrité : Méthode qui permet de vérifier qu'un fichier n'a pas été modifié au cours du temps. Les informations comme la taille, la date et l'heure de dernière modification, la somme de contrôle éventuelle du fichier sont analysées lors de la demande d'ouverture du fichier par l'utilisateur (si analyse en temps réel) ou lors d'un scan de l'AV.
Le but de notre expérience est de tester si il est possible de faire un déni de service lorsque l'AV analyse une bombe de compression. En complément à l'article sur le contournement d’antivirus.
Nous avons testé deux AV pour Linux : ClamAV (www.clamav.net) et Comodo (www.comodo.com)


Les agrégateurs d'AV sont des outils qui permettent d'analyser des fichiers avec plusieurs AV en même temps. Le résultat obtenu en analysant un fichier avec ce type d'outils est plus fiable qu'avec un seul AV. Cependant, cet outil ne doit pas remplacer un AV installé sur une machine. Il existe deux types d’agrégateurs. 


Ce sont des sites web spécialisés dans la détection de malwares grâce à des dizaines antivirus différents. Un partenariat relie les éditeurs d'AV et un site de ce type. Ce sont ses éditeurs qui mettent à disposition des sites leur programme. Ce qui signifie que les éditeurs sont responsables de leur configuration. Il peut arriver qu'un AV sur ce genre de site ne soit pas exactement configuré comme la version commerciale. En effet, il s'agit d'un bon moyen pour les éditeurs de tester de nouvelles fonctionnalités, configurations. Lorsqu'un fichier est soumis par un utilisateur sur cette plateforme, il est analysé par les moteurs des différents AV. Dans le cas où au moins un AV détecte un fichier comme malveillant, le fichier est envoyé aux éditeurs des AV qui ne l'on pas détecter pour l'améliorer. Nous avons choisis 3 sites pour réaliser nos tests :

VirusTotal : www.virustotal.com, filiale de Google basée en Espagne, hébergé dans le Cloud, comprenant 57 AV et est le plus populaire avec en moyenne 1.5M de soumissions par jours (dont 16.6% provenant de France).
Jotti : virusscan.jotti.org, organisation basée aux Pays-Bas, hébergé dans le Cloud, comprenant 19 AV.
Virscan : www.virscan.org, organisation basée en chine, comprenant 39 AV.


Pour utiliser ce service, un utilisateur doit envoyer le fichier suspect vers le site pour que les moteurs des différents AV puissent l'analyser. Après analyse, ce fichier n'est pas détruit, car il est envoyé aux éditeurs d'AV pour améliorer leurs programmes. Il n'est donc pas concevable pour une personne (physique ou morale) d'envoyer des fichiers avec des données sensibles vers des serveurs dont cette personne n'a pas de contrôle. C'est pourquoi il existe aussi les « Framework de détection de malwares ».

Ce genre d'outils fonctionne donc en local, idéalement sur une machine virtuelle pour éviter de contaminer la machine hôte. Ce sont des programmes qui permettent à un utilisateur d'analyser un fichier suspect de différentes façons via des plugins. Pour notre étude, nous avons utilisé deux Framework : 

Mastiff, www.korelogic.com, société basée aux USA, composée de professionnels en sécurité informatique.
Viper, www.viper.li, créé par Claudio Guarnieri.

Ses deux outils sont préinstaller dans la distribution REMnux (remnux.org) qu'il est facile d'importer dans Virtualbox https://www.virtualbox.org.
Mastiff fonctionne de la manière suivante :
cf image.
Mastiff et Viper permettent entre autre:

 D’identifier et classer le type des fichiers analysé grâce aux règles de YARA, plusvic.github.io/yara.
 Reconnaître deux fichiers dont le contenu est très similaire grâce au fuzzy hashing (ssdeep). Prenons par exemple les commandes suivantes : "echo message1 > fichier1.txt" et "echo message2 > fichier2.txt". Les deux fichiers générer auront des digests très différents avec aucune ressemblance possible. Cependant, grâce à ssdeep il est possible de faire ressortir le fait que ses deux fichiers sont presque identiques. Technique pratique pour repérer les malwares polymorphes.
 Extraire et analyser récursivement des fichiers zip. C'est notamment cette dernière qui nous intéresse et que nous allons tester.


Les IDS ou sondes de détection d'intrusion sont des programmes permettant d'analyser le trafic réseau de manière transparente. Idéalement l'IDS est situé au point d'entrer du réseau d'une entreprise pour pouvoir analyser tout le trafic réseau. L'IDS fonctionne sur un système de règles et de pattern matching. Un administrateur définit un certain nombre de règles que l'IDS doit vérifier lors de l'analyse du trafic réseau. Suivant les règles que l’administrateur a définies, l'IDS permet : 
De laisser passer un paquet sans finir l'analyse.
Rejeter le paquet, en générant des paquets ICMP erreur ainsi qu'une alerte
Générer une alerte dans le fichier de logs.
Par exemple, l'administrateur peut décider de créer une règle  qui générera une alerte lors qu'une connexion sera établie sur les serveurs de Facebook. Cette alerte permet d'identifier l'adresse IP source de la requête HTTP.
Le pattern matching fonctionne aussi avec le contenu des paquets qui circulent sur le réseau. De cette manière une règle peut être créée pour générer une alerte lorsqu'un paquet contient les caractères "Euros 2016" par exemple.
L'IDS que nous avons choisis de tester est Suricata. Suricata se démarque de la concurrence par une analyse multithread. Avec toujours de plus en plus de données, l'analyse rapide et efficace devient de plus en plus important. L'article de David J. Day et Benjamin M. Burns analyse les performances de Suricata. Suricata supporte nativement l'IPv6 et est open source. Suricata extrait les fichiers compressés pour analyser leur contenu. Le but de l’étude est de vérifier qu'il n'y a pas de déni de service possible lorsque Suricata analyse une bombe de compression.

Dans un premier temps, nous avons généré un exécutable Windows (payload via metasploit) connu pour être analyser comme un malware par la plupart des outils disponibles sur le marché. Ensuite, pour chacun des outils, nous avons effectué une analyse témoin. Cette analyse se compose du fichier générer précédemment, et d'un fichier contenant uniquement des zéros et qui est donc complètement inoffensif.
Dans un second temps, nous avons analysé les résultats des deux premiers fichiers compressés dans différents formats : .gz, .lzma, .tar.bz2, .tar.gz, .tar.xz, .lz, .lzo, .zip
Et enfin, nous avons analysé l'impact des bombes de compression sur ses outils pour vérifier leur robustesse sur un éventuel déni de service.
Pour rappel : lorsqu'un fichier compressé de petite taille (42 Ko) se décompresse en un autre fichier d'une taille très largement supérieur (4.5 Po), c'est ce qu'on appelle une bombe de compression (42.zip).
Dans notre expérience, les fichiers décompressés sont de taille : 250 Mo, 500 Mo, 1 Go, 4.5 Po.

Nous avons réalisé les tests (et installer les outils nécessaires) sur une machine ayant un OS Linux (Ubuntu 12.04 LTS).
Après avoir installé ClamAV (via les dépôts Ubuntu/Debian) nous avons effectué des tests dans sa configuration initiale. Pour lancer un scan dans le répertoire courant, il suffit de la commande "clamscan" (avec la configuration initiale). Cependant, deux paramètres sont à prendre en compte pour mener à bien cette expérience :

"max-recursion= n" : La récursion lors de l'analyse des fichiers compressés, 16 par défaut.
"max-filesize= n" : Extrait et analyse  n octets de chaque archives. 25 Mo par défaut avec une limite de 4 Go.


Nous avons également installé un second antivirus : Comodo (via package du site officiel). Il dispose d'une interface graphique, mais ne nous permet pas de modifier des paramètres comme la récursion, ou la taille des fichiers analysés. Pour lancer un scan, il faut suivre les indications sur l'interface graphique.

VirusTotal met à notre disposition une API permettant d'envoyer des fichiers pour analyse via un script. Nous avons alors repris puis modifier un script existant pour effectuer nos tests. Ce script (écrit en Perl) effectue deux requêtes vers VirusTotal. Une première (HTTP POST) pour envoyer le fichier suspect. Et une seconde, pour récupérer le résultat sous forme d'un objet JSON. Ensuite le script génère un rapport mis en forme. Ce rapport contient le résultat des antivirus partenaires de VirusTotal.

En ce qui concerne Jotti et Virscan, nous avons utilisé l'interface web pour soumettre nos fichiers et récupérer les résultats.

Mastiff est un programme dont le processus peut être exécuté dans un docker. Dans ce cas, un dossier est partagé entre la VM et le docker. Dans ce dossier, nous avons au préalable placé les fichiers à analyser par Mastiff. Dans le cas présent, nous n'avons pas de fichier confidentiel, c'est pourquoi nous avons ajouté l'option d'envoyer les fichiers à analyser vers VirusTotal automatiquement. Lors de son analyse, Mastiff génère un fichier de résultat par moteur d'analyse.

Viper est aussi un programme dont le processus peut s’exécuter dans un docker. A la différence que Viper met à notre disposition une interface web, à partir de laquelle nous pouvons soumettre nos fichiers. Une fois un fichier soumis, une multitude de commandes peuvent être lancées pour tester le fichier suspect. Les résultats de ses commandes se retrouvent sur cette interface web.

Après avoir installé Suricata, nous avons rédigé des règles pour que les fichiers soient décompressés puis inspectés. 
%Cependant, Suricata étant un cas particulier de cette expérience, notre but ici est de voir si nous pouvons faire un déni de service lorsque Suricata va décompresser un fichier.
Nous avons pris soin de modifier la configuration initiale de Suricata pour que l'extraction se passe de manière optimale :

stream.reassembly.depth = 4gb, après avoir réassemblé le flux TCP, le fichier ne doit pas dépasser une taille de 4Go.
request_body_limit = 0 (infini), valeur que le corps de la requête HTTP ne peut pas dépasser.
response_body_limit = 0 (infini), valeur que le corps de la réponse HTTP ne peut pas dépasser.

De plus, sur une autre machine nous avons installé un serveur web disposant des fichiers à tester par Suricata. Ainsi, avec une simple requête sur le serveur, Suricata reconstitue le fichier puis l'inspecte.
